{"version":3,"sources":["../node_modules/typescript/lib sync","fixtures/exampleSpec.ts","utils/typescript.ts","utils/common.ts","utils/mocha.ts","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","exampleSpec","getParsedSourceFile","Project","createSourceFile","getCallIdentifier","node","Node","isExpressionStatement","expression","getExpression","isCallExpression","leftHandSideExpression","isIdentifier","getText","getChildOfKind","kind","result","forEachChild","n","getKind","getBlocksInside","child","isBlock","push","getCallbackBlock","callExpression","SyntaxKind","CallExpression","functionExpression","FunctionExpression","ArrowFunction","Block","removeSurroundingChars","text","trim","substring","length","mochaHooks","getDescribeCalls","level","isDescribe","isDescribeCall","title","getMochaCallTitle","flattenDescribeSpecs","sourceFile","describeCalls","forEach","describeCall","replaceWithText","block","logPrefix","hooks","children","getChildren","befores","filter","isMochaCallOfType","afters","map","getFullText","join","getFlattenedHooks","eachHooks","getFlattenedEachHooks","sections","sortDescribeContent","isMochaHook","flattenNodes","before","main","flattenDescribeSpec","prettier","format","parser","plugins","parserTypescript","useTabs","singleQuote","trailingComma","arrowParens","endOfLine","_","formatText","containsItOrDescribe","reduce","prev","curr","flatten","newLogPrefix","prependLog","eachHooksInside","wrapCodeWithEachHooks","after","flattenDescribe","getCyLog","flattenIt","flattenHook","flattenBlock","flattenBlocksInside","nodes","prefix","log","beforeEach","getFlattenedEachHooksOfType","afterEach","hookType","currentSection","type","callIdentifier","includes","stringLiteral","StringLiteral","templateExpression","TemplateExpression","App","useState","setSourceFile","selected","setSelected","disabled","setDisabled","targetFile","setTargetFile","useEffect","selectedDescribes","getFirstChild","getParent","index","className","style","display","flexDirection","overflowY","height","width","defaultLanguage","defaultValue","onChange","value","options","minimap","enabled","lineNumbers","padding","borderLeft","borderRight","describe","paddingLeft","checked","event","describes","newSelected","newDisabled","a","following","slice","levelBelow","i","ind","onChangeSelected","target","readOnly","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ff48862b.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 33;","const exampleSpec = `\n// paste spec here\n\n// example:\n\ndescribe('test D', () => {\n\n\tbefore(() => {\n\t\tbeforeCommand();\n\t});\n\n\tit('should test 1', () => {\n\t\tcommand1();\n\t});\n\n\tit('should test 2', () => {\n\t\tcommand2();\n\t});\n\n});\n`;\n\nexport default exampleSpec;\n","import { SyntaxKind, Node, ts, SourceFile, Project } from 'ts-morph';\n\nexport function getParsedSourceFile(code: string): SourceFile {\n  const project = new Project();\n  return project.createSourceFile('code.ts', code);\n}\n\nexport function getCallIdentifier(node: Node<ts.Node>): string {\n  if (Node.isExpressionStatement(node)) {\n    const expression = node.getExpression();\n    if (Node.isCallExpression(expression)) {\n      const leftHandSideExpression = expression.getExpression();\n      if (Node.isIdentifier(leftHandSideExpression)) {\n        return leftHandSideExpression.getText();\n      }\n    }\n  }\n\n  return '';\n}\n\nexport function getChildOfKind(node: Node<ts.Node>, kind: SyntaxKind): Node<ts.Node> | undefined {\n  let result: Node<ts.Node> | undefined;\n\n  node.forEachChild(n => {\n    if (n.getKind() === kind) {\n      result = n;\n    }\n  });\n\n  return result;\n}\n\nexport function getBlocksInside(node: Node<ts.Node>): Node<ts.Node>[] {\n\tconst result: Node<ts.Node>[] = [];\n\n\tnode.forEachChild(child => {\n\t\tif (Node.isBlock(child)) {\n\t\t\tresult.push(child);\n\t\t} else {\n\t\t\tresult.push(...getBlocksInside(child));\n\t\t}\n\t});\n\n\treturn result;\n}\n\nexport function getCallbackBlock(node: Node<ts.Node>): Node<ts.Node> | undefined {\n  const callExpression = getChildOfKind(node, SyntaxKind.CallExpression);\n  if (!callExpression) return;\n\n  const functionExpression = getChildOfKind(callExpression, SyntaxKind.FunctionExpression) || getChildOfKind(callExpression, SyntaxKind.ArrowFunction);\n  if (!functionExpression) return;\n\n\tconst block = getChildOfKind(functionExpression, SyntaxKind.Block);\n\treturn block;\n}\n","export function removeSurroundingChars(text: string) {\n  return text.trim().substring(1, text.length - 1);\n}\n","import { SyntaxKind, Node, ts, SourceFile } from 'ts-morph';\nimport prettier from 'prettier/standalone';\nimport parserTypescript from 'prettier/parser-typescript';\n\nimport { getCallIdentifier, getChildOfKind, getCallbackBlock, getBlocksInside } from './typescript';\nimport { removeSurroundingChars } from './common';\n\nexport const mochaHooks = ['afterEach', 'after', 'beforeEach', 'before'];\nexport const mochaFunctions = ['describe', 'it', ...mochaHooks];\n\nexport interface DescribeCall {\n  title: string;\n  level: number;\n  node: Node<ts.Node>;\n}\n\ninterface DescribeSections {\n  before: Node<ts.Node>[];\n  main: Node<ts.Node>[];\n  after: Node<ts.Node>[];\n}\n\ninterface EachHooks {\n\tbeforeEach: string;\n\tafterEach: string;\n}\n\nexport function getDescribeCalls(node: Node<ts.Node> | SourceFile, level: number = 0): DescribeCall[] {\n  const result: DescribeCall[] = [];\n\n  node.forEachChild(n => {\n    const isDescribe = isDescribeCall(n);\n\n    if (isDescribe) {\n      result.push({\n        title: getMochaCallTitle(n),\n        level,\n        node: n,\n      });\n    }\n\n    result.push(...getDescribeCalls(n, isDescribe ? level + 1 : level));\n  });\n\n  return result;\n}\n\nexport function flattenDescribeSpecs(sourceFile: SourceFile, describeCalls: DescribeCall[]): string {\n  describeCalls.forEach(describeCall => {\n    describeCall.node.replaceWithText(flattenDescribeSpec(describeCall.node));\n  });\n    \n  try {\n    return prettier.format(sourceFile.getText(), {\n      parser: 'typescript',\n      plugins: [ parserTypescript ],\n      useTabs: true,\n      singleQuote: true,\n      trailingComma: 'all',\n      arrowParens: 'always',\n      endOfLine: 'lf',\n    });\n  } catch (_) {\n    sourceFile.formatText();\n    return sourceFile.getText();\n  }\n}\n\nfunction flattenDescribeSpec(node: Node<ts.Node>): string {\n  const block = getCallbackBlock(node);\n\n  if (!block) return '';\n\n  const logPrefix = '';\n  const hooks = getFlattenedHooks(block);\n  const eachHooks = getFlattenedEachHooks(block, logPrefix);\n  const children = getChildren(block).filter(node => !isMochaHook(node));\n  const sections = sortDescribeContent(children);\n\n  return `\n    describe(\\`${getMochaCallTitle(node)}\\`, () => {\n      ${flattenNodes(sections.before, logPrefix)}\n      \n      ${hooks}\n      \n      it('should pass', () => {\n        ${flattenNodes(sections.main, logPrefix, eachHooks)}\n      });\n    });\n  `;\n}\n\nfunction containsItOrDescribe(node: Node<ts.Node>): boolean {\n\treturn getChildren(node).reduce<boolean>((prev, curr) => {\n\t\tif (prev) return true;\n\t\tif (isMochaCallOfType(curr, 'it') || isMochaCallOfType(curr, 'describe')) return true;\n\t\treturn containsItOrDescribe(curr);\n\t}, false);\n}\n\nfunction flatten(node: Node<ts.Node>, logPrefix: string, eachHooks?: EachHooks): string {\n\tif (isMochaCallOfType(node, 'describe')) {\n\t\treturn flattenDescribe(node, logPrefix, eachHooks);\n\t} else if (isMochaCallOfType(node, 'it')) {\n\t\treturn flattenIt(node, logPrefix, eachHooks);\n\t} else if (isMochaHook(node)) {\n\t\treturn flattenHook(node, logPrefix);\n\t} else if (Node.isBlock(node)) {\n\t\treturn flattenBlock(node, logPrefix, eachHooks);\n\t} else {\n\t\tif (containsItOrDescribe(node)) {\n\t\t\tflattenBlocksInside(node, logPrefix, eachHooks);\n\t\t}\n\t\t\n\t\treturn node.getFullText();\n\t}\n}\n\nfunction flattenDescribe(node: Node<ts.Node>, logPrefix: string, eachHooks?: EachHooks): string {\n  const block = getCallbackBlock(node);\n\n  if (!block) return '';\n\n  const sections = sortDescribeContent(getChildren(block));\n  const newLogPrefix = prependLog(logPrefix, getMochaCallTitle(node));\n  const eachHooksInside = getFlattenedEachHooks(block, newLogPrefix);\n\n  const result = `\n    {\n      ${flattenNodes(sections.before, newLogPrefix)}\n\n      ${flattenNodes(sections.main, newLogPrefix, eachHooksInside)}\n\n      ${flattenNodes(sections.after, newLogPrefix)}\n    }\n  `;\n\n  return wrapCodeWithEachHooks(result, eachHooks);\n}\n\nfunction flattenNodes(nodes: Node<ts.Node>[], logPrefix: string, eachHooks?: EachHooks): string {\n  return nodes\n    .map(node => flatten(node, logPrefix, eachHooks))\n    .join(' ');\n}\n\nfunction flattenIt(node: Node<ts.Node>, logPrefix: string, eachHooks?: EachHooks): string {\n  const block = getCallbackBlock(node);\n  \n  if (!block) return '';\n\n  return `\n    ${getCyLog(logPrefix, node)}\n    ${wrapCodeWithEachHooks(block.getFullText(), eachHooks)}\n  `;\n}\n\nfunction flattenHook(node: Node<ts.Node>, logPrefix: string): string {\n  const block = getCallbackBlock(node);\n\n  if (!block) return '';\n    \n  return `\n    ${getCyLog(logPrefix, node)}\n    ${block.getFullText()}\n  `;\n}\n\nfunction flattenBlock(block: Node<ts.Node>, logPrefix: string, eachHooks?: EachHooks): string {\n  const result: string[] = [];\n\n  block.forEachChild(child => {\n    result.push(flatten(child, logPrefix, eachHooks));\n  });\n\n  return result.join('\\n');\n}\n\nfunction flattenBlocksInside(node: Node<ts.Node>, logPrefix: string, eachHooks?: EachHooks) {\n  const blocksInside = getBlocksInside(node);\n\n  blocksInside.forEach(block => {\n    block.replaceWithText(`{${flatten(block, logPrefix, eachHooks)}}`);\n  });\n}\n\nfunction getCyLog(prefix: string, node: Node<ts.Node>): string {\n  const log = `${getCallIdentifier(node)} ${getMochaCallTitle(node)}`.trim();\n\n  return `cy.log(\\`${prependLog(prefix, log)}\\`);`;\n}\n\nfunction prependLog(prefix: string, log: string): string {\n  return `${prefix ? `${prefix} - ` : ''}${log}`;\n}\n\nfunction getFlattenedEachHooks(block: Node<ts.Node>, logPrefix: string): EachHooks {\n  return {\n    beforeEach: getFlattenedEachHooksOfType(block, 'beforeEach', logPrefix),\n    afterEach: getFlattenedEachHooksOfType(block, 'afterEach', logPrefix),\n  };\n}\n\nfunction getFlattenedEachHooksOfType(block: Node<ts.Node>, hookType: string, logPrefix: string): string {\n  return getChildren(block)\n    .filter(node => isMochaCallOfType(node, hookType))\n    .map(node => flatten(node, logPrefix))\n    .join('\\n');\n}\n\nfunction getFlattenedHooks(block: Node<ts.Node>): string {\n  const children = getChildren(block);\n\n  const befores = children.filter(node => isMochaCallOfType(node, 'before'));\n  const afters = children.filter(node => isMochaCallOfType(node, 'after'));\n\n  return [...befores, ...afters].map(node => node.getFullText()).join('\\n');\n}\n\nfunction wrapCodeWithEachHooks(code: string, eachHooks?: EachHooks): string {\n  if (eachHooks) {\n    return eachHooks.beforeEach + code + eachHooks.afterEach;\n  } else {\n    return code;\n  }\n}\n\nfunction sortDescribeContent(nodes: Node<ts.Node>[]): DescribeSections {\n  const sections: DescribeSections = {\n    before: [],\n    main: [],\n    after: [],\n  };\n\n  let currentSection = sections.before;\n\n  nodes.forEach(node => {\n    if (isMochaCallOfType(node, 'before')) {\n      sections.before.push(node);\n    } else if (isMochaCallOfType(node, 'after')) {\n      sections.after.push(node);\n    } else if (!isMochaHook(node)) {\n      if (isMochaCallOfType(node, 'it') || isMochaCallOfType(node, 'describe') || containsItOrDescribe(node)) {\n        currentSection = sections.main;\n      }\n  \n      currentSection.push(node);\n    }\n  });\n\n  return sections;\n}\n\nfunction isDescribeCall(node: Node<ts.Node>): boolean {\n  if (Node.isExpressionStatement(node)) {\n    const callIdentifier = getCallIdentifier(node);\n    return callIdentifier === 'describe';\n  }\n\n  return false;\n}\n\nfunction isMochaCallOfType(node: Node<ts.Node>, type: string): boolean {\n  if (Node.isExpressionStatement(node)) {\n    const callIdentifier = getCallIdentifier(node);\n    return callIdentifier === type;\n  }\n\n  return false;\n}\n\nfunction isMochaHook(node: Node<ts.Node>): boolean {\n  if (Node.isExpressionStatement(node)) {\n    const callIdentifier = getCallIdentifier(node);\n    return mochaHooks.includes(callIdentifier);\n  }\n\n  return false;\n}\n\nfunction getMochaCallTitle(node: Node<ts.Node>): string {\n  const callExpression = getChildOfKind(node, SyntaxKind.CallExpression);\n  if (!callExpression) return '';\n\n  const stringLiteral = getChildOfKind(callExpression, SyntaxKind.StringLiteral);\n  if (stringLiteral) {\n    return removeSurroundingChars(stringLiteral.getText());\n  };\n\n  const templateExpression = getChildOfKind(callExpression, SyntaxKind.TemplateExpression);\n  if (templateExpression) {\n    return removeSurroundingChars(templateExpression.getText());\n  }\n\n  return '';\n}\n\nfunction getChildren(node: Node<ts.Node>): Node<ts.Node>[] {\n  const result: Node<ts.Node>[] = [];\n\n  node.forEachChild(child => {\n    result.push(child)\n  });\n  \n  return result;\n}\n","import React, { useState, useEffect } from 'react';\nimport Editor from '@monaco-editor/react';\n\nimport exampleSpec from '../fixtures/exampleSpec';\nimport { getParsedSourceFile } from '../utils/typescript';\nimport { getDescribeCalls, flattenDescribeSpecs } from '../utils/mocha';\n\nfunction App() {\n  const [sourceFile, setSourceFile] = useState(getParsedSourceFile(exampleSpec));\n  const [selected, setSelected] = useState<number[]>([]);\n\tconst [disabled, setDisabled] = useState<number[]>([]);\n  const [targetFile, setTargetFile] = useState('');\n\n  useEffect(() => {\n    if (!sourceFile) return;\n\n\t\tconst targetFile = getParsedSourceFile(sourceFile.getFullText());\n\n\t\tconst describes = getDescribeCalls(targetFile.getFirstChild()?.getParent()!);\n\t\tconst selectedDescribes = describes.filter((_, index) => selected.includes(index));\n\n\t\tsetTargetFile(flattenDescribeSpecs(targetFile, selectedDescribes));\n  }, [sourceFile, selected]);\n\n\tfunction onChangeSelected(prev: number[], index: number, checked: boolean): number[] {\n\t\tif (!sourceFile) return [];\n\t\t\n\t\tconst describes = getDescribeCalls(sourceFile);\n\n\t\tlet newSelected = [...prev];\n\t\tlet newDisabled = [...disabled];\n\n\t\tif (checked) {\n\t\t\tnewSelected.push(index);\n\t\t} else {\n\t\t\tnewSelected = newSelected.filter(a => a !== index);\n\t\t}\n\n\t\tif (index < describes.length - 1) {\n\t\t\tconst following = describes\n\t\t\t\t.map((node, index) => ({ node, index }))\n\t\t\t\t.slice(index + 1)\n\n\t\t\tlet levelBelow = true;\n\n\t\t\tfor (let i = 0; i < following.length && levelBelow; i++) {\n\t\t\t\tif (following[i].node.level <= describes[index].level) {\n\t\t\t\t\tlevelBelow = false;\n\t\t\t\t} else {\n\t\t\t\t\tconst ind = following[i].index;\n\t\t\t\t\tif (checked) {\n\t\t\t\t\t\tnewSelected = newSelected.filter(a => a !== ind);\n\t\t\t\t\t\tnewDisabled.includes(ind) || newDisabled.push(ind);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewDisabled = newDisabled.filter(a => a !== ind);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsetDisabled(newDisabled);\n\t\treturn newSelected;\n\t}\n\n  return (\n    <div className=\"App\" style={{ display: 'flex', flexDirection: 'row', overflowY: 'hidden' }}>\n      <Editor\n        height=\"100vh\"\n        width=\"40vw\"\n        defaultLanguage=\"typescript\"\n        defaultValue={exampleSpec}\n        onChange={value => {\n\t\t\t\t\tsetDisabled([]);\n\t\t\t\t\tsetSelected([]);\n          if (value) {\n            setSourceFile(getParsedSourceFile(value));\n          }\n        }}\n\t\t\t\toptions={{\n\t\t\t\t\tminimap: {\n\t\t\t\t\t\tenabled: false,\n\t\t\t\t\t},\n\t\t\t\t\tlineNumbers: \"off\",\n\t\t\t\t}}\n      />\n      <div style={{ width: '20vw', padding: 20, borderLeft: '1px solid lightgrey', borderRight: '1px solid lightgrey' }}>\n\t\t\t\t<h2>source spec -{'>'} flattened spec</h2>\n\t\t\t\tSelect <i>describes</i> you want to flatten:\n\t\t\t\t<br /><br />\n        {sourceFile && getDescribeCalls(sourceFile)\n\t\t\t\t\t.map((describe, index) => {\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<div key={index}>\n\t\t\t\t\t\t\t\t<label style={{ paddingLeft: describe.level * 20 }}>\n\t\t\t\t\t\t\t\t\t<input type=\"checkbox\" checked={selected.includes(index)} disabled={disabled.includes(index)} onChange={event => {\n\t\t\t\t\t\t\t\t\t\tsetSelected(prev => {\n\t\t\t\t\t\t\t\t\t\t\treturn onChangeSelected(prev, index, event.target.checked);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}} />\n\t\t\t\t\t\t\t\t\t{' '}{describe.title}\n\t\t\t\t\t\t\t\t</label>\n\t\t\t\t\t\t\t\t<br />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t);\n        \t})\n\t\t\t\t}\n      </div>\n      <div>\n        <Editor\n          height=\"100vh\"\n          width=\"40vw\"\n          defaultLanguage=\"typescript\"\n          value={targetFile}\n\t\t\t\t\toptions={{\n\t\t\t\t\t\treadOnly: true,\n\t\t\t\t\t\tminimap: {\n\t\t\t\t\t\t\tenabled: false,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tlineNumbers: \"off\",\n\t\t\t\t\t}}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}